//*******************************************
// Get the original page and parse its data to JavaScript object
//*******************************************
async function loadDocPage(docPage){
    let response = await fetch(docPage);
    let html = await response.text();
    let dom = new DOMParser().parseFromString(html, "text/html");
    content = { docPage };

    // Load informations for a rustdoc page
    if (dom 
        && dom.querySelector("meta[name=generator]") 
        && dom.querySelector("meta[name=generator]").content == "rustdoc")
    {
        internalLinks(dom);
        loadRustdocContent(dom, content);
    }
    // Load informations from a mdBook page
    else if (html.indexOf("<!-- Book generated using mdBook -->")>0) {
        loadBookContent(dom, content);
    }
    else {
        alert("Not a valid rustdoc page!");
        console.log("Not a valid rustdoc page");
        return;
    }

}

//*******************************************
// Load a page generated by the Rustdoc tool
//*******************************************
function loadRustdocContent(dom, content) {
    // Prepare regexp
    let rxSelfType = /^.*\((.*?self.*?),.*$/;
    let rxReturnType = /^.*->(.*?)( where .*)?$/;

    // Get item type
    let sidebarScript = dom.querySelector(".sidebar-elems script").textContent;
    let typeText = sidebarScript.replace(/.*ty: '(.*?)'.*/,"$1");
    content.type = DocItems[typeText];

    //Remove important-trait notification
    for (node of dom.querySelectorAll(".important-traits")) {
        node.remove();
    }

    // Get item title as HTML
    content.domTitle = dom.querySelector(".fqn .in-band").cloneNode(true);
    
    // Get item description
    content.domDescription = dom.querySelector(".docblock:not(.type-decl):not(.attributes)").cloneNode(true);

    // Get item declaration
    let decl_src=dom.querySelector(".type-decl");
    if (decl_src){
        content.domDeclaration=decl_src.cloneNode(true);
    }

    // For module, get sub-items
    let module_items = dom.querySelectorAll(".module-item");
    if (module_items.length>0){
        content.items=[];
        for (domItem of module_items){
            let item = {};
            // Get item type
            let a = domItem.firstChild.firstChild;
            item.type = DocItems[a.className];
            // Ignore special items
            if (item.type.to) {continue;}
            // Get name
            item.name = a.textContent;
            // Get href
            item.href = a.getAttribute("href");
            // Get description
            item.domDescription = domItem.children[1].cloneNode(true);
            // push
            content.items.push(item);
        }  
    }

    // Get implementations and methods
    let fns = {};
    let cur_impl;
    let section;
    for (item of dom.querySelectorAll("h2.small-section-header, .impl, .method")){
        //sections of documented items 
        if (item.tagName=="H2"){
            section=sectionsInfo[item.id];
            if (section.fakeImpl) {
                item.classList.add("impl");
            }
        }
        //actual implementation or single fake implementation to contain special
        //section items (derefed, required method, ...)
        if (item.classList.contains("impl")) {
            let impl = {};
            // mark the implementation with his special type (deref, provided, ...)
            impl[section.property] = true;
            
            // get the generic text repesentation
            if (section.fakeImpl) {
                impl.domDeclaration=document.createElement("code");
                impl.domDeclaration.innerHTML=item.innerHTML;
            } else {
                impl.domDeclaration = item.firstChild.cloneNode(true);
            }
            // get the declaration (exctract the since and src info if available) 
            let domSince = item.querySelector("span.since");
            if (domSince) {
                impl.since = domSince.textContent;
            }
            let domSrc = item.querySelector("a.srclink")
            if (domSrc) {
                impl.src = domSrc.getAttribute("href");
            }
            // parse the declaration to extract type info and produce reduced version
            parseImplDeclaration(impl);
            // try to get info for special Trait (operators, iterators,...)
            getSpecialImpl(impl);

            impl.fns = [];
            cur_impl = impl;

            // push the implementation in the corresponding matching array
            let list = section.list;
            if (!content[list]) content[list]= []; 
            content[list].push(impl);
        }
        //method
        if (item.classList.contains("method")) {
            //TODO: handle associated items
            if (section.property=="associated"){
                continue;
            }
            let fn = {};
            //From the <h4> method header :
            // get the name of the method
            let nameItem = item.querySelector(".fnname");
            fn.name = nameItem.firstChild.textContent;
            fn.domName= nameItem.cloneNode(true);
            // get release version if availible
            let domSince = item.querySelector("span.since");
            if (domSince) {
                fn.since = domSince.textContent;
            }
            // get source if available
            let domSrc = item.querySelector("a.srclink")
            if (domSrc) {
                fn.src = domSrc.getAttribute("href");
            }         
            // get self an return type
            let fnCode = item.querySelector("code").textContent;
            fn.selfType = fnCode.match(rxSelfType)
                ? fnCode.replace(rxSelfType, "$1")
                : "No self";
            fn.returnType = fnCode.match(rxReturnType)
                ? fnCode.replace(rxReturnType, "$1")
                : "()";
            
            //From the <div> folowing the method header (if available)
            // get stability an deprecation info
            var next = item.nextElementSibling;
            if (next && next.querySelector(".stability .unstable")){
                fn.unstable=true;
                next=next.nextElementSibling;
            }
            if (next && next.querySelector(".stability .deprecated")){
                fn.deprecated=true;
                next=next.nextElementSibling;
            }    
            // get description
            if (next){
                fn.shortDescription = next.textContent.split(".",2)[0] + ".";
                fn.domDescription = next.cloneNode(true); 
            }

            //Push the extracted informations in the lists
            cur_impl.fns.push(fn);
            fn.impl = cur_impl;
            if (section.list=="impls"){
                if (!fns[fn.name]) {
                    fns[fn.name]=[];
                }
                fns[fn.name].push(fn);
            }
        }            
    }
    if (Object.keys(fns).length>0) { 
        fns=orderObject(fns);
        content.fns=fns;
    }
} 

function orderObject(obj){
    let arr = [];
    for (fld in obj) {
        arr.push({name: fld, content: obj[fld]})
    }
    arr.sort((x,y) => {
        if (x.name < y.name) return -1
        else if (x.name > y.name) return 1
        else return 0;
    });
    let objSorted={};
    for (fld of arr){
        objSorted[fld.name]=fld.content;
    }
    return objSorted;
}

//****************************************************
// Parse the implementation declaration to extract the main parts
//****************************************************
function parseImplDeclaration(impl) {
    let prefix = "";
    let text = "";
    let info = false;
    let elt = impl.domDeclaration;

    //get the name of the type documented on this page
    let a = content.domTitle.querySelectorAll("a")
    let mainType=a[a.length-1].textContent;

    //normalize whitespace
    text = elt.textContent.trim();
    text = text.replace(/\s/g," ");

    //methods from deref ("...Deref<Target=Type>" => "from Type") 
    if (impl.deref) {
        prefix = "from";
        //extract type between "=" and ">"
        text = text.replace(/.*?=(.*).*>/,"$1");
    }
    //required method => "required"
    else if (impl.required) {
        prefix = "required";
        text = "";
    }
    //
    else if (impl.provided || impl.associated) {
        prefix = "";
        text = "";
    }
    //method from implementation
    else if (impl.implementation || impl.synthetic || impl.blanket || impl.typeImpl || impl.traitImpl) {
        //extract the generic impl parameters
        let pos = 4;
        if (text.startsWith("impl<")){
            pos = getBlock(text,4,"<",">");
            impl.generics = text.substring(4,pos);
            //if the elided arguments carry a bound, send a notice
            if (impl.generics.includes(":")) info=true;
        }
        text=text.substring(pos).trim();
        
        //extract the where clause 
        var posWhere = text.indexOf(" where ");
        if (posWhere > 0){
            impl.whereClause = text.substring(posWhere+7);
            text = text.substring(0,posWhere);
            //send a notice if where clause present
            info=true;
        } 

        //extract for clause and prepare a shortened one
        let posFor = text.indexOf(" for ");
        if (posFor > 0) {
            impl.forClause = text.substring(posFor+5).trim();
            text = text.substring(0,posFor);
            //if the clause is not exactly on the current type send a notice 
            if (impl.forClause!=mainType+impl.generics) info=true;
            impl.shortForClause = impl.forClause.replace(/<.*/,"<…>");
        }

        //extract the implemented trait and prepared shortened one
        impl.trait=text.trim();
        impl.shortTrait=impl.trait.replace(/<.*/,"<…>");
        if (impl.trait.startsWith(mainType) && impl.trait!=mainType+impl.generics){
            info=true
        }

        //select the final case
        if (impl.trait.startsWith(mainType)){
            //case "impl DocumentedTye for Type" => "for Type"
            if (impl.forClause && !impl.forClause.includes(mainType)){
                prefix="for";
                text=impl.shortForClause;
            }
            //case "impl DocumentedType" => ""
            else {
                text="";
            }
        }
        //case "impl Type for DocumentedType" => "Type"
        else {
            text=impl.shortTrait;
        }
    }
    
    // construct the short declaration : prefix + text + infoTag
    impl.domShortDeclaration = document.createElement("span");
    if (prefix!="") {
        let eltPrefix = document.createElement("span");
        eltPrefix.className="prefix";
        eltPrefix.appendChild(document.createTextNode(prefix+" "));
        impl.domShortDeclaration.appendChild(eltPrefix);
    }    
    impl.domShortDeclaration.appendChild(document.createTextNode(text));    
    if (info) {
        impl.domShortDeclaration.appendChild(document.createTextNode("\xA0"))
        let sup = document.createElement("sup");
        sup.appendChild(document.createTextNode("🛈"));
        impl.domShortDeclaration.appendChild(sup);
    }
}

//get the special implementations 
function getSpecialImpl(impl) {
    // only for trait implementation
    if (!impl.trait || !impl.forClause) return;

    // detect implemented operators
    let bareTrait=impl.trait.replace(/<.*/,"");
    let op = operatorTraits.filter(function (op){
        if (op.trait.endsWith("::"+bareTrait)) return true;
        if (op.hide && op.hide.endsWith("::"+bareTrait)) return true;
        return false;
    });    
    if (op.length > 0) { impl.operators = op }

    //detect iterators
    if (["Iterator"].includes(bareTrait)){
        let decl = item.nextElementSibling.querySelector("[id^=associatedtype\\.Item] code");
        let type = document.createElement("span");
        let afterEq = false;
        for (node of decl.childNodes) {
            if (afterEq){type.appendChild(node.cloneNode(true))}
            let text = node.textContent.trim();
            if (text.startsWith("=")){
                type.appendChild(document.createTextNode(text.replace("=","")));
                afterEq = true;
            }
        }
        impl.iterator = type;
    }

    if (["From","TryFrom"].includes(bareTrait) && !impl.blanket){
        impl.convert = true;
    }
}

//Given a position on a string, return the position of the matching closing bracket
function getBlock(str, start, open, close){
    if (str[start]!=open) return -1;
    let count =1;
    var pos;
    for (pos=start+1; count>0; pos++){
        if (pos>=str.length) return -1;
        if (str[pos]==open) count++;
        if (str[pos]==close) count--;
    }
    return pos;
}

//*******************************************
// Load a page generated by mdBook
//*******************************************
function loadBookContent(dom, content){
    alert("Book page not implemented yet");
}

//*******************************************
// Change links to load doc internaly if possible
//*******************************************
function internalLinks(dom){
    let currentItemPath = pathParent(content.docPage);
    for (a of dom.querySelectorAll("a")){
        let originalLink = a.getAttribute("href");
        let href;
        // if it is an empty or an absolute link keep it unchanged
        if (originalLink==null
            ||originalLink.startsWith("http:")
            ||originalLink.startsWith("https:")
            ||originalLink.startsWith("javascript:"))
        {
            continue;
        }
        // if there is only a tag, we stay on the same page 
        else if (originalLink.startsWith("#")) {
            let rawPage = content.docPage.replace(/#.*/,"");
            href = rawPage + originalLink;
        }
        // set the new sub-page relative to the current one
        else {
            href = pathMerge(currentItemPath, originalLink);
        }
        a.href = realPageUrl + "?item=" + href;
        //a.onclick = function(){ goToPage(href); return false; }
        a.setAttribute("onclick", "goToPage('" + href + "'); return false;"); 
    }
}

//*******************************************
// Load sidebar content
//*******************************************
function initSidebar() {
    tree = [
        {
            type: DocItems.bookshelf, 
            text:"Guides", 
            child : {
                type: DocItems.book, 
                text:"The Rust Programming Language", 
                url:"book"
            }
        }, 
        {
            type: DocItems.primitive, 
            text:"Primitives"
        }, 
        {
            type: DocItems.keyword, 
            text:"Keywords"
        },
    ];
}

const operatorTraits = [
    {symbol: "..", trait: "std::ops::Range"},
    {symbol: "..", trait: "std::ops::RangeFrom"},
    {symbol: "..", trait: "std::ops::RangeFull"},
    {symbol: "..=", trait: "std::ops::RangeInclusive"},
    {symbol: "..=", trait: "std::ops::RangeTo"},
    {symbol: "..=", trait: "std::ops::RangeToInclusive"},
    {symbol: "+", trait: "std::ops::Add"},
    {symbol: "+=", trait: "std::ops::AddAssign"},
    {symbol: "&", trait: "std::ops::BitAnd"},
    {symbol: "&=", trait: "std::ops::BitAndAssign"},
    {symbol: "|", trait: "std::ops::BitOr"},
    {symbol: "|=", trait: "std::ops::BitOrAssign"},
    {symbol: "^", trait: "std::ops::BitXor"},
    {symbol: "^=", trait: "std::ops::BitXorAssign"},
    {symbol: "/", trait: "std::ops::Div"},
    {symbol: "/=", trait: "std::ops::DivAssign"},
    {symbol: "[]", trait: "std::ops::Index"},
    {symbol: "[]", trait: "std::ops::IndexMut"},
    {symbol: "*", trait: "std::ops::Mul"},
    {symbol: "*=", trait: "std::ops::MulAssign"},
    {symbol: "-", trait: "std::ops::Neg"},
    {symbol: "!", trait: "std::ops::Not"},
    {symbol: "%", trait: "std::ops::Rem"},
    {symbol: "%=", trait: "std::ops::RemAssign"},
    {symbol: "<<", trait: "std::ops::Shl"},
    {symbol: "<<=", trait: "std::ops::ShlAssign"},
    {symbol: ">>", trait: "std::ops::Shr"},
    {symbol: ">>=", trait: "std::ops::ShrAssign"},
    {symbol: "-", trait: "std::ops::Sub"},
    {symbol: "-=", trait: "std::ops::SubAssign"},
    {symbol: "<", trait: "std::cmp::PartialOrd", hide:"std::cmp::Ord"},
    {symbol: "<=", trait: "std::cmp::PartialOrd", hide:"std::cmp::Ord"},
    {symbol: ">", trait: "std::cmp::PartialOrd", hide:"std::cmp::Ord"},
    {symbol: ">=", trait: "std::cmp::PartialOrd", hide:"std::cmp::Ord"},
    {symbol: "==", trait: "std::cmp::PartialEq", hide:"std::cmp::Eq"},
    {symbol: "!=", trait: "std::cmp::PartialEq", hide:"std::cmp::Eq"}
];

const sectionsInfo={
    "associated-types": {property:"associated", fakeImpl: true, list: "impls"},
    "required-methods": {property:"required", fakeImpl: true, list: "impls"},
    "provided-methods": {property:"provided", fakeImpl: true, list: "impls"},
    "methods": {property:"typeImpl", fakeImpl: false, list: "impls"},
    "deref-methods": {property:"deref", fakeImpl: true, list: "impls"},
    "implementations": {property:"traitImpl", fakeImpl: false, list: "impls"},
    "synthetic-implementations": {property:"synthetic", fakeImpl: false, list: "impls"},
    "blanket-implementations": {property:"blanket", fakeImpl: false, list: "impls"},
    "foreign-impls": {fakeImpl: true, list:"foreignImpls"},
    "implementors": {fakeImpl: true, list: "implementors"},
    "synthetic-implementors": {fakeImpl: false, list: "implementors"},
    "variants": {property:"variant", fakeImpl:false},
    "fields": {property:"field", fakeImpl:false}
};
