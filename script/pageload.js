//*******************************************
// Get the original page and parse its data to JavaScript object
//*******************************************
async function loadDocPage(docPage){
    let response = await fetch(docPage);
    let html = await response.text();
    let dom = new DOMParser().parseFromString(html, "text/html");
    content = { docPage };

    // Load informations for a rustdoc page
    if (dom.querySelector("meta[name=generator]").content == "rustdoc") {
        internalLinks(dom);
        loadRustdocContent(dom, content);
    }
    // Load informations from a mdBook page
    else if (html.indexOf("<!-- Book generated using mdBook -->")>0) {
        loadBookContent(dom, content);
    }
    else {
        alert("Not a valid rustdoc page!");
        console.log("Not a valid rustdoc page");
        return;
    }

}

//*******************************************
// Load a page generated by the Rustdoc tool
//*******************************************
function loadRustdocContent(dom, content) {
    // Get item type
    let sidebarScript = dom.querySelector(".sidebar-elems script").textContent;
    let typeText = sidebarScript.replace(/.*ty: '(.*?)'.*/,"$1");
    content.type = DocItems[typeText];

    // Get item title as HTML
    content.domTitle = dom.querySelector(".fqn .in-band").cloneNode(true);
    
    // Get item description
    content.domDescription = dom.querySelector(".docblock:not(.type-decl):not(.attributes)").cloneNode(true);

    // Get item declaration
    let decl_src=dom.querySelector(".type-decl");
    if (decl_src){
        content.domDeclaration=decl_src.cloneNode(true);
    }

    // For module, get sub-items
    let module_items = dom.querySelectorAll(".module-item");
    if (module_items.length>0){
        content.items=[];
        for (domItem of module_items){
            let item = {};
            // Get item type
            let a = domItem.firstChild.firstChild;
            item.type = DocItems[a.className];
            // Ignore special items
            if (item.type.to) {continue;}
            // Get name
            item.name = a.textContent;
            // Get href
            item.href = a.getAttribute("href");
            // Get description
            item.domDescription = domItem.children[1].cloneNode(true);
            // push
            content.items.push(item);
        }  
    }

    // Get implementations and methods
    let impls = [];
    let fns = {};
    let cur_impl = null;
    for (item of dom.querySelectorAll("h3.impl, h4.method, h2#deref-methods")){
        //implementation
        if (item.tagName!="H4"){
            let impl = {};
            impl.text = item.firstChild.textContent;
            impl.domDeclaration = item.firstChild.cloneNode(true);
            if (item.parentNode && item.parentNode.id=="blanket-implementations-list"){
                impl.blanket=true;
            }
            if (item.tagName=="H2") {
                impl.deref=true;
                impl.domDeclaration=document.createElement("code");
                impl.domDeclaration.innerHTML=item.innerHTML;
            }
            let domSince = item.querySelector("span.since");
            if (domSince) {
                impl.since = domSince.textContent;
            }
            let domSrc = item.querySelector("a.srclink")
            if (domSrc) {
                impl.src = domSrc.getAttribute("href");
            }
            impl.fns = [];
            cur_impl = impl;
            impls.push(impl);
        }
        //method
        else {
            let fn = {};
            let nameItem = item.querySelector(".fnname");
            fn.name = nameItem.firstChild.textContent;
            fn.domName= nameItem.cloneNode(true);
            let descItem = item.nextElementSibling;
            var next = item.nextElementSibling;
            if (next.querySelector(".stability .unstable")){
                fn.unstable=true;
                next=next.nextElementSibling;
            }
            if (next.querySelector(".stability .deprecated")){
                fn.deprecated=true;
                next=next.nextElementSibling;
            }
            let domSince = item.querySelector("span.since");
            if (domSince) {
                fn.since = domSince.textContent;
            }
            let domSrc = item.querySelector("a.srclink")
            if (domSrc) {
                fn.src = domSrc.getAttribute("href");
            }
            fn.shortDescription = next.textContent.split(".",2)[0] + ".";
            fn.domDescription = next.cloneNode(true); 
            cur_impl.fns.push(fn);
            fn.impl = cur_impl;
            if (!fns[fn.name]) {
                fns[fn.name]=[];
            }
            fns[fn.name].push(fn);
        }            
    }
    orderObject(fns);
    if (impls.length>0) { 
        content.impls=impls;
        content.fns=fns;
    }
} 

function orderObject(obj){
    let arr = [];
    for (fld in obj) {
        arr.push({name: fld, content: obj[fld]})
    }
    arr.sort((x,y) => {
        if (x.name < y.name) return -1
        else if (x.name > y.name) return 1
        else return 0;
    });
    let objSorted={};
    for (fld of arr){
        objSorted[fld.name]=fld.content;
    }
    return objSorted;
}

//*******************************************
// Load a page generated by mdBook
//*******************************************
function loadBookContent(dom, content){
    alert("Book page not implemented yet");
}

//*******************************************
// Change links to load doc internaly if possible
//*******************************************
function internalLinks(dom){
    let currentItemPath = pathParent(content.docPage);
    for (a of dom.querySelectorAll("a")){
        let originalLink = a.getAttribute("href");
        let href;
        // if it is an empty or an absolute link keep it unchanged
        if (originalLink==null
            ||originalLink.startsWith("http:")
            ||originalLink.startsWith("https:")
            ||originalLink.startsWith("javascript:"))
        {
            continue;
        }
        // if there is only a tag, we stay on the same page 
        else if (originalLink.startsWith("#")) {
            let rawPage = content.docPage.replace(/#.*/,"");
            href = rawPage + originalLink;
        }
        // set the new sub-page relative to the current one
        else {
            href = pathMerge(currentItemPath, originalLink);
        }
        a.href = realPageUrl + "?item=" + href;
        a.onclick = function(){ goToPage(href); return false; }
    }
}

const operators = [
    {symbol: "..", trait: "std::ops::Range"},
    {symbol: "..", trait: "std::ops::RangeFrom"},
    {symbol: "..", trait: "std::ops::RangeFull"},
    {symbol: "..=", trait: "std::ops::RangeInclusive"},
    {symbol: "..=", trait: "std::ops::RangeTo"},
    {symbol: "..=", trait: "std::ops::RangeToInclusive"},
    {symbol: "+", trait: "std::ops::Add"},
    {symbol: "+=", trait: "std::ops::AddAssign"},
    {symbol: "&", trait: "std::ops::BitAnd"},
    {symbol: "&=", trait: "std::ops::BitAndAssign"},
    {symbol: "|", trait: "std::ops::BitOr"},
    {symbol: "|=", trait: "std::ops::BitOrAssign"},
    {symbol: "^", trait: "std::ops::BitXor"},
    {symbol: "^=", trait: "std::ops::BitXorAssign"},
    {symbol: "/", trait: "std::ops::Div"},
    {symbol: "/=", trait: "std::ops::DivAssign"},
    {symbol: "[]", trait: "std::ops::Index"},
    {symbol: "[]", trait: "std::ops::IndexMut"},
    {symbol: "*", trait: "std::ops::Mul"},
    {symbol: "*=", trait: "std::ops::MulAssign"},
    {symbol: "-", trait: "std::ops::Neg"},
    {symbol: "!", trait: "std::ops::Not"},
    {symbol: "%", trait: "std::ops::Rem"},
    {symbol: "%=", trait: "std::ops::RemAssign"},
    {symbol: "<<", trait: "std::ops::Shl"},
    {symbol: "<<=", trait: "std::ops::ShlAssign"},
    {symbol: ">>", trait: "std::ops::Shr"},
    {symbol: ">>=", trait: "std::ops::ShrAssign"},
    {symbol: "-", trait: "std::ops::Sub"},
    {symbol: "-=", trait: "std::ops::SubAssign"},
    {symbol: "<", trait: "std::cmp::PartialOrd", hide:"std::cmp::Ord"},
    {symbol: "<=", trait: "std::cmp::PartialOrd", hide:"std::cmp::Ord"},
    {symbol: ">", trait: "std::cmp::PartialOrd", hide:"std::cmp::Ord"},
    {symbol: ">=", trait: "std::cmp::PartialOrd", hide:"std::cmp::Ord"},
    {symbol: "==", trait: "std::cmp::PartialCmp", hide:"std::cmp::Cmp"},
    {symbol: "!=", trait: "std::cmp::PartialCmp", hide:"std::cmp::Cmp"}
];
